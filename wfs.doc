\documentclass[11pt]{article}
\usepackage{times}
\usepackage{pl}
\usepackage{plpage}
\usepackage{html}
\sloppy
\makeindex

\renewcommand{\runningtitle}{Tabling in SWI-Prolog}

\begin{document}

\title{Tabling in SWI-Prolog \\ (for dummies)}
\author{Jan Wielemaker \\
        CWI, Amsterdam \\
        The Netherlands \\
        E-mail: \email{J.Wielemaker@cwi.nl}}

\maketitle

\begin{abstract}
This technical report describes the tabling implementation of SWI-Prolog.
This implementation is based on \jargon{delimited continuations} rather
than the SLG WAM engine as used by XSB Prolog. The aim of this report is
twofold: explain what is needed to implement tabling as simple as
possible and provide a guideline for understanding the actual
implementation used by SWI-Prolog.
\end{abstract}

\tableofcontents

\section{Introduction}

Tabling is an extension to Prolog that turns Prolog into a much more
\jargon{declarative} language. It makes programs less dependent on the
ordering of clauses and subgoals in clauses, provides termination in the
case of \jargon{left recursion} and some tabling implementations realise
sound \jargon{negation} according to the \jargon{Well Founded
Semantics}. Dealing with left recursion as well as well founded
semantics is realised by \jargon{suspending} (delaying) problematic
goals. Effectively, tabling realises \jargon{bottom up} evaluation of
problematic goals that contribute to a top down goal evaluation
strategy. This also hints at two of its three drawbacks: memory usage
and the need to keep tables consistent with the program.

The third drawback is the complexity. Here we notably refer to the
complexity of implementing tabling. However, tabling is also complex to
the user because the user has to decide which predicates of the program
must be tabled and tabled execution does not follow simple depth first
left-to-right search. The non-trivial execution order turns an execution
\jargon{trace} into an incomprehensible series of actions.

The original tabling implementation using the SLG WAM as pioneered in
XSB Prolog has only been replicated by YAP. B-Prolog implements a
simpler variant called \jargon{linear tabling}. Ciao implements tabling
largely through complex program transformation. Many people have tried
to come up with simpler ways to implement tabling \cite{?,?}. Benoit
Desouter realised tabling \cite{DBLP:journals/tplp/DesouterDS15} on top
of \jargon{delimited continuations}
\cite{DBLP:journals/tplp/SchrijversDDW13} as a fairly small Prolog
library.

This report describes the current SWI-Prolog tabling implementation.
This implementation is still based on the work by Benoit Desouter,
although large parts of the implementation were moved to C for
performance. The implementation has been extended by Fabrizio Riguzzi to
deal with \jargon{answer subsumption} and by Jan Wielemaker with help
from Therase Swift and David S. Warren to deal with well founded
semantics. The beauty of the continuation based implementation is that
it is relatively simple and has no consequences for the core Prolog
virtual machine. This allows us to describe the implementation of
tabling as capturing and calling continuations rather then modifications
that turn a WAM implementation into an SLG-WAM implementation.

With this high-level description we provide a reading guide for the
actual implementation in SWI-Prolog. At the same time we provide a more
accessible description of implementing tabling which we hope will
inspire developers and will demistify tabling for a category of users.

\section{Delimited continuations}
\label{sec:dcont}

Explicit handling of \jargon{continuations} is notably popular in
functional programming. Tom Schrijvers brought them to Prolog
\cite{DBLP:journals/tplp/SchrijversDDW13}. Continuations were first of
all introduced as a way to realise \jargon{coroutining} in
Prolog.\footnote{The term \jargon{coroutining} is ambiguous in Prolog.
It is primarily used for goals that are triggered by unification through
\jargon{attributed variables} In this document we do \emph{not} refer to
\jargon{attributed variables}.}. Delimited continuations are realised
through two predicates: reset/3 and shift/1.

\begin{description}
    \predicate{reset}{3}{:Goal, ?Ball, -Continuation}
\nodescription
    \predicate{shift}{1}{+Ball}
Run \arg{Goal}. If shift/1 is called somewhere during the evaluation of
\arg{Goal} and shift's \arg{Ball} unifies with our \arg{Ball}, unify
\arg{Continuation} with a callable term that captures the remainder of
the execution of \arg{Goal} and make the reset/3 goal succeed. If
shift/1 is \emph{not} called during the execution of \arg{Goal},
\arg{Continuation} is unified with the integer 0.
\end{description}

The behaviour is best described using a demo. Consider the program
in \figref{dcont}. Its execution consists of the following steps:

\begin{enumerate}
    \setlength{\itemsep}{0pt}
    \item Calling go/0 calls reset/3, calls p/0.
    \item p/0 writes ``Hello''.
    \item p/0 calls shift/1.  Shift's \arg{Ball} unifies with the
          reset/3 \arg{Ball}.  Shift/1 makes reset/3 succeed binding
	  \arg{Continuation} to a callable term that runs the remainder
	  of p/0, in this case \term{writeln}{Y}.
    \item Go/0 takes the second branch of the if-then-else, unifies
          the \arg{Ball}'s argument to \const{world} and calls the
	  continuation.
    \item p/0 completes
    \item go/0 completes.
\end{enumerate}

\begin{figure}[ht]
\begin{code}
p :- write('Hello '), shift(get(Y)), writeln(Y).

go :-
    reset(p, get(X), Continuation),
    (   Continuation == 0
    ->  true
    ;	X = world,
        call(Continuation)
    ).

?- go.
Hello world
true.
\end{code}
    \caption{A program using delimited continuations}
    \label{fig:dcont}
\end{figure}


Technically, a continuation is a list of \jargon{environments}, each
consisting of a \jargon{clause}, a \jargon{program counter} pointing
into the code of this clause and an array of \jargon{registers}
that belong to this environment. Calling the continuation implies
restoring the environment and resume its execution. Provided we make
sure the referenced clauses are not modified we can, instead of
immediately calling the continuation as in go/0, store the continuation
(for example using assertz/1) and run it at as many times as we wish at
any point in time.


\section{Tabling using delimited continuations}

\subsection{Tabling 0.0}

In its simplest form tabling stores the answer of a call
\jargon{variant} in a table, represented as a \jargon{trie}. A term
(goal) is a \jargon{variant} of another term if a renaming of variables
exists that makes the two terms equivalent. A simple Prolog definition
of variant is below. The term copying is needed to deal with the case
where \arg{T1} and \arg{T2} share variables.

\begin{code}
variant(T1, T2) :-
    \+ \+ ( copy_term(T1, Ta),
	    numbervars(Ta, 0, End),
	    numbervars(T2, 0, End),
	    Ta == T2 ).
\end{code}

Any subsequent call that is a variant of the tabled goal the answers
from this \jargon{answer trie} rather than using the clauses to generate
answers. This simple form can be illustrated using the program in
\figref{tabling0}. Note that the tables are stored in a trie-of-tries.
The global \jargon{variant trie} maps goals to tables (\jargon{answer
tries}) that contain the answers for this goal. Tabling in general does
not maintain order of answers and avoids duplicate answers.


\begin{figure}[ht]
\begin{code}
run_tabled(Goal) :-
    variant_trie(VTrie),
    trie_lookup(VTrie, Goal, ATrie),
    !,
    trie_gen(ATrie, Goal).
run_tabled(Goal) :-
    variant_trie(VTrie),
    trie_new(ATrie),
    trie_insert(VTrie, Goal, ATrie),
    (   call(Goal),
	trie_insert(ATrie, Goal),
	fail
    ;   true
    ),
    trie_gen(ATrie, Goal).
\end{code}
    \caption{Tabling 0.0: memoizing only}
    \label{fig:tabling0}
\end{figure}

The above tabling implementation avoids repetitive evaluation of the
same goal, but is still sensitive to the non-terminating \jargon{left
recursion}, i.e., if somewhere during the execution of \arg{Goal} a
variant of \arg{Goal} is triggered the execution will go into an
infinite recursion.


\subsection{Tabling 0.5}

Tabling 0.5 detects non-termination due to left recursion. It achieves
this goal by detecting it is calling a variant of itself as a subgoal.
The first step is to associate three states for each variant:
\jargon{fresh} means we see this variant for the first time,
\jargon{complete} means we enumerated all its answers and finally,
\jargon{incomplete} implies we started the failure driven loop of the
second clause of \figref{tabling0}, but did not yet finish it. We first
introduce two new predicates to keep our code concise. After that we can
refine our program to detect the problematic left recursion as in
\figref{tabling05}

\begin{description}
    \predicate{answer_table}{3}{:Goal, -ATrie, -Status}
Get the answer table for \arg{Goal} and return its status as
\const{fresh} (we just created the table), \const{incomplete}
(we started filling it) and \const{complete} (we filled it).
This predicate combines variant_trie/1, its lookup or adding
an answer trie and maintaining a status flag on the answer trie.
    \predicate{complete_table}{1}{+ATrie}
Set the status of \arg{ATrie} to \const{complete}.
\end{description}

\begin{figure}[ht]
\begin{code}
run_tabled(Goal) :-
    answer_table(Goal, ATrie, Status),
    (   Status == complete
    ->  trie_gen(ATrie, Goal)
    ;   Status == fresh
    ->  (   call(Goal),
	    trie_insert(ATrie, Goal),
	    fail
        ;   complete_table(ATrie)
	),
	trie_gen(ATrie, Goal)
    ;   panic("Left recursion!")
    ).
\end{code}
    \caption{Tabling 0.5: detect left recursion}
    \label{fig:tabling05}
\end{figure}


\subsection{Tabling 1.0}

In this step we will fix the left recursion. We do that, and this is the
crucial element of all advanced tabling, by \jargon{delaying}
problematic goals. First, let us consider the program \exam{p :- p.}
Under the \jargon{Closed World Assumption} this program has no answers.
If we change this to the following however, p/0 becomes \const{true}.

\begin{code}
p :- p.
p.
\end{code}

This might make us believe we can simply fail if we find a call variant
(the panic/1 case above). That is not true. Consider the program below.
this has three answers: \exam{p(1)}, \exam{p(2)} and \exam{p(3)}.

\begin{code}
p(X) :- p(Y), Y < 3, X is Y+1.
p(1).
\end{code}

How do we get these answers? We \jargon{delay} if we find an incomplete
variant, i.e. if we call \term{p}{Y} in the first clause. Delaying
remembers the ``given an answer $Y$ for \term{p}{Y}, we must execute the
remainder of the clause to get a new answer''. Execution continues with
the remainder of the program, producing \exam{p(1)}. Now we can execute
the delayed remainder of the clause, producing \exam{p(2)}, which can be
used to execute the delayed remainder of the clause once more to produce
\exam{p(3)}. \exam{p(3)} is again used to execute the delayed remainder
of the clause, but \exam{Y < 3} prevents it from producing an answer and
thus we reached \jargon{fixed point}.

At this moment we must recall \secref{dcont}. ``Remember the remainder
of the clause'' means that calling a variant of an incomplete tabled
goal should call shift/1! Shift passes a ball of the shape
\term{call_info}{Variant, Worklist}. \arg{Worklist} is a data structure
associated with the answer trie of the variant that keeps track of
answers and continuations that must be executed using these answers. It
is discussed in \secref{worklist}. In the above example, calling
\term{p}{Y} in the first clause calls \exam{shift(call_info(p(Y),
WorklistForPVar))}. The \jargon{scheduler} which is also discussed in
\secref{worklist} can unify \term{p}{Y} with a new answer for the
variant \term{p}{Var}, run the continuation and add a possible answer to
the worklist of the variant to which the continuation belongs.

First, we need to capture the shift/1 call. This must be done by the
\jargon{leader}, the code running the first encounter of a variant. The
code for running a leader is a refinement of the code running the
failure driven loop of \figref{tabling05} and shown in
\figref{leader10}. The predicate activate/3 creates a worklist for the
variant and starts the failure driven loop guarded by reset/3. If the
execution does not encounter an incomplete tabled variant
\arg{Continuation} is \exam{0} and we can add the answer. Otherwise we
add a \jargon{dependency}\footnote{also referred to as
\jargon{suspension}} which consists of the continuation and sufficient
context to bind the variables (\arg{DepVariant}) and, if the
continuation succeeds, the answer term and the worklist into which to
put this answer (\arg{Variant} and \arg{Worklist}).

If a new answer becomes available for \arg{DepWorklist}, we can
propagate this using the steps below.  \jargon{Completion} must
run this propagation until fixed point is reached.

\begin{enumerate}
    \setlength{\itemsep}{0pt}
    \item Unify this answer with \arg{DepVariant},
    \item Call \arg{Continuation} using a failure driven loop
    \item For each answer
    \begin{enumerate}
	\item Add \arg{Variant} to \arg{Worklist}
    \end{enumerate}
\end{enumerate}

\begin{figure}
\begin{code}
%!  activate(+Variant, +ATrie, -Worklist)

activate(Variant, ATrie, Worklist) :-
    new_worklist(ATrie, Worklist),
    (   delim(Variant, Worklist),
	fail
    ;   true
    ).

delim(Variant, Worklist) :-
    reset(Variant, CallInfo, Continuation),
    (   Continuation == 0	% no shift: we have an answer
    ->  add_answer(Worklist, Variant)
    ;   CallInfo = call_info(DepVariant, DepWorklist),
	add_suspension(
	    DepWorklist,
	    dependency(DepVariant, Continuation, Variant, Worklist))
    ).
\end{code}
    \label{fig:leader10}
    \caption{Running a leader variant using continuations}
\end{figure}

\subsubsection{The worklist and scheduling component}
\label{sec:worklist}

A worklist is a data structure associated with an answer trie. It keeps
track of the dependencies (see \figref{leader10}) that must be executed
for each answer in this answer trie. Note that the completion process
needs to run until fixed point is reached and each iteration may add
answers to each of the answers tries involved in a graph of dependent
goal variants. The data structure for a worklist is a double linked list
of answer and dependency clusters. It is maintained as follows

\begin{itemize}
    \item If a new answer is added to the variant trie, make sure
    this answer (the trie node) is added to an answer cluster at
    the head (left side) of the list. If the head of the list is a
    dependency cluster, first add a new answer cluster as new head.
    Otherwise simply add the answer to the cluster.
    \item If a new dependency is added to the worklist, add it to
    a dependency cluster at the tail (right side) of the list. Again, if
    the tail is not a dependency cluster, create one.
\end{itemize}

Now, each answer must be used with each dependency further down the list
(further to the right).  Propagating a worklist implies:

\begin{enumerate}
    \setlength{\itemsep}{0pt}
    \item Take a dependency cluster and find the first answer cluster
    to its left. This answer cluster contains answers that must be fed
    into the the dependencies.
    \item Swap the two clusters, moving the answer cluster to the right
    of the dependency cluster.
    \item Combine the answers and dependencies from the clusters.  Note
    that this process combines all answers with all dependencies,
    i.e. the Cartesian product.  Note that as a result, new answers
    may be added at the left and new dependencies at the right.
\end{enumerate}

To keep track of a collection of mutually dependent variants we use a
\jargon{scheduling component}. A component keeps track of two sets: a
set with all worklists that belong to the component and a subset thereof
of all worklists that have answers that must be combined with
dependencies which we call the \jargon{active} set.\footnote{The code
calls this the \jargon{global} worklist set} Whenever an answer is
added to a worklist, this worklist is added to the active subset.
Completing a component consists of the following scheduling loop

\begin{enumerate}
    \setlength{\itemsep}{0pt}
    \item While the active worklist subset is not empty
    \begin{enumerate}
	\item Remove the first worklist from the active subset
        \item Run the worklist propagation step above until there
        are no answer clusters left of a dependency cluster.  Note
        that this process may create answers, which may add worklists
        to the active set.
    \end{enumerate}
    \item Mark all tables in the component as \const{complete}.
\end{enumerate}

This algorithm completes tabling as it was implemented by Benoit
Desouter and described in \cite{DBLP:journals/tplp/DesouterDS15}. This
implementation used a single component that was created by the first
tabled goal and remained active until that goal and all tabled goals
that were encountered during the execution of the the outermost goal
were complete.

\section{Optimizing: answer skeletons}

Above, the answer tries contain complete \jargon{instances}\footnote{An
instance of a term is copy of that term in which at least one variable
is unified, possibly with another variable of the copy.} of the goal
variant. This is inefficient for variants that have output variables
before the (instantiated) input arguments. Here, `before' means earlier
in the top-down and left-right traversal of the goal term. For this
reason, if a new variant is detected we create a pair consisting of the
full goal term and a term of the shape \term{ret}{V1, ...}, containing
all the variables that appear in the variant goal. The answer trie
contains instances of the ret/\arg{N} term.

\section{Answer subsumption}

\jargon{Answer subsumption} splits the set of arguments of a tabled
goals into two subsets. One subset is used to determine that a new goal
is a variant of an existing term and the other subset is used to compute
a value for each argument that \jargon{subsumes} all generated values.
For example, the following declaration derives the minimum price for
each product.

\begin{code}
:- table product_price(+, min).
\end{code}

Computing the subsuming answer can also be considered as an
\jargon{aggregation} process. The initial value is typically the value
associated with the first answer. Subsequent answers are subsequently
used to update the aggregated answer.

The implementation uses the declaration to generate a term that is used
to determine the call variant. For the example above this is
\verb|'$product_price$2'(Var)|. Note that this name includes the
\jargon{arity} of the goal because a predicate product_price/3 may have
the same arity-1 variant. The declaration is also used to generate a
clause for the predicate \predref{'\$table_update'}{4} that is used to
compute the next aggregated answer, given the current and a new answer.
The answer trie node that represents a specific answer is extended with
a \jargon{record} (see \secref{record} that represents the aggregated
answer.

TODO: walk through the above with a concrete example.


\section{Dynamic strongly connected components}
\label{sec:SCC}

The implementation of the previous section uses a single scheduling
component. This implies that any tabled goal that is activated as a
result of the outermost tabled goal that created the component will be
completed together with the outermost goal. Incomplete goals are
fragile. Notably, if choice points from an incomplete goal are pruned
due to a cut, the table has an incomplete set of answers.  Incomplete
goals are also slow because we have to use the suspension mechanism.

For these reasons tabled goals should be completed as early as possible.
Note that variant goals only need to be together in a component if they
depend on each others answers. Thus, if a fresh tabled variant is
discovered while tabling is in progress we can create a \jargon{sub
component}. If none of the tabled goals encountered while completing
this subcomponent refers to an incomplete variant in another component
all variant goals in the sub component can be marked as completed before
we continue with the containing component.

When to use a sub component can be decided using static analysis, but
this is complex and imprecise because different variants of a goal may
have different dependencies. Therefore a dynamic solution is preferable.
This is realised as follows:

\begin{itemize}
    \setlength{\itemsep}{0pt}
    \item If a fresh variant is encountered, create a sub component
    for it.  The newly created worklist points to the new component.
    \item If a call to an incomplete variant is found
    \begin{itemize}
	\item If the worklist of the incomplete variant points at
	the current sub component, just continue.
	\item Otherwise the worklist points to a worklist higher
	in the component hierachy.  Merge all components into the
	higher component.
    \end{itemize}
\end{itemize}

A component merge can be part of the completion step. The completion
process is stopped when the component is merged. The leader that
activated this completion detects the merge and turns itself into a
follower by calling shift/1. In addition, all answers that are already
in the answer trie must be made available to the new
dependency.\footnote{Implemented by \$tbl_wkl_make_follower/1.}

\section{Dynamic statified negation}
\label{sec:negdstrat}

Without precautions, tabling is incompatible with negation, unless the
negated goal has no dependencies on incomplete goals higher in the call
tree. If there are no such dependencies, the eager completion as
described in \secref{SCC} is sufficient to make negation work. This
section describes how to make negation sound for a large class of
programs: those where negation can be \jargon{dynamically stratified}.
\jargon{Stratification} implies (re)organizing the program in
independent layers such that we can solve the bottom layer
\jargon{statum} unambiguously and subsequently propagate the results to
the higher layers. Consider the program below. This problem is
\emph{not} stratified as it involves infinite recursion. It can be
solved using tabling because tabling will suspend on the recursive goal
to \term{connected}{B,A}, fill the table using the facts and then
execute the continuation containing \term{connected}{B,A} for all the
derived one-directional connections.

\begin{code}
connected(A,B) :- connected(B,A).

connected(amsterdam, haarlem).
connected(amsterdam, shiphol).
connected(haarlem,   leiden).
connected(shiphol,   leiden).
\end{code}

We can also accomplish the same result using program transformation as
illustrated below.

\begin{code}

connected(A, B) :- track(A, B).
connected(A, B) :- track(B, A).

track(amsterdam, haarlem).
track(amsterdam, shiphol).
track(haarlem,   leiden).
track(shiphol,   leiden).
\end{code}

In other words, tabling realises a \jargon{dynamically} stratified
program. Negation requires special attention. We can decide on a
negative literal under two condition, (a) we have an answer (in our
table) that makes the negation false or (b) we have no answer and there
is no execution path (dependent suspended node) that can produce one. In
the latter case the negation is true and this fact can be propagated
through obtain the final result. In all other cases we use the central
technique of tabling: delay what you cannot decide upon.

Tabled negation is implemented by tnot/1. \Figref{tnotdstrat} shows the
implementation dealing with stratified negation. The implementation of
tnot/1 is further refined in \secref{WFS}.  The steps are:

\begin{enumerate}
    \setlength{\itemsep}{0pt}
    \item If we can decide, we are done.  This is the case if the answer
    trie has an answer or its complete (and empty).
    \item Otherwise if the variant is fresh, run it and redo the
    decision process of step (1).
    \item If the variant is incomplete call negation_suspend/2, creating a
    \jargon{negative suspension node}.
\end{enumerate}

Negative suspension nodes are handled differently during completion. The
completion process first goes through the completion process described
in \secref{worklist}. When done, it searches for a negative suspension
node that has no answers and wakes it up, running negation_suspend/2
after the shift/1 call.

\begin{figure}
\begin{code}
tnot(Goal) :-
    answer_table(Goal, ATrie, Status),
    (   trie_gen(ATrie, _)
    ->  fail
    ;   Status == complete
    ->  true
    ;   Status == fresh
    ->  (   call(Goal),
	    fail
	;   answer_table(Goal, ATrie, NewStatus),
	    (   trie_gen(ATrie, _)
	    ->  fail
	    ;   Status == complete
	    ->  true
	    ;   % incomplete, Status is the worklist
		negation_suspend(Goal, Status)
	    )
	)
    ;   % incomplete, Status is the worklist
	negation_suspend(Goal, Status)
    ).

negation_suspend(Goal, Worklist) :-
    worklist_set_negative(Worklist),
    shift(call_info(Goal, tnot(Worklist))),
    worklist_is_false(Worklist).
\end{code}
    \caption{Stratified negation}
    \label{fig:tnotdstrat}
\end{figure}

As a result, \emph{if the program can be dynamically stratified} this
implementation will produce the correct result. This implementation
however does not deal correctly with cases that cannot be dynamically
stratified. Two examples of such programs are below. For p/0 the
implementation decides that the negative node p/0 has no answers and
thus that p/0 is true. For q/0 and r/0, the implementation will decide
that one of the two negations is true, making the other false. According
to the \jargon{stable model semantics}, p/0 has no stable model and q/r
has two, from which our implementation picks one at random.  This issue
is the topic of \secref{WFS}

\begin{code}
p :- tnot(p).

q :- tnot(r).
r :- tnot(q).
\end{code}


\section{Well Founded Semantics}
\label{sec:WFS}

\jargon{Well Founded Semantics} (WFS)
\cite{DBLP:journals/jacm/GelderRS91} is a three valued logical theory
about negation. Literals can have the truth value \jargon{true},
\jargon{false} and a third that expresses that WFS cannot decide on the
truth value. This third value is referenced to as \jargon{bottom},
\jargon{unknown}, \jargon{undefined} or
\jargon{indeterminate}.\footnote{Indeterminate was recently proposed by
David S Warren.}.

The implementation of WFS takes the delay strategy to a next level.
Instead of simply assuming that a negative literal without answers is
true, the negative literal is now \jargon{conditionally true}. In other
words, just as in \secref{negdstrat} we continue the execution of
negative literals without answers. Any answer that results from running
these continuations though is stored as a \jargon{conditional answer}.
Consider the following program:

\begin{code}
p :- tnot(q).
q :- tnot(p), fail.
\end{code}

It is obvious that normal tabling cannot resolve any of these goals.
Dynamic stratification will produce an answer that differs on whether
q/0 is considered false or p/0 is considered false. With
\jargon{delaying} we assume q/0 is false, deriving that p/0 is true if
q/0 is false. Next, we assume that p/0 is false, which does not derive
anything due to the \exam{fail}. Now q/0 is no answers, neither
conditional or unconditional and is thus false. This can be propagated,
making the answer for q/0 unconditionally true because it condition (q/0
being false) is satified.

The above used negative conditions. There are also positive conditions.
These are created if an answer is produced due to using a conditional
answer. Consider the program below. This is nearly identical to the one
above. At some point p/0 gets a conditional answer (on tnot(q)). This
answer is propagated to r/0, but as p/0 is a conditional answer r/0 is
registered to be true iff the answer for p/0 becomes unconditional.

\begin{code}
r :- p.
p :- tnot(q).
q :- tnot(p), r, fail.
\end{code}

Completion under well founded semantics consists of the following steps:

\begin{enumerate}
    \setlength{\itemsep}{0pt}
    \item Normal tabled completion
    \item Continue undecided negative literals, possibly producing
    conditional answers.  New answers are propagated using the normal
    tabled completion, but the results are conditional on these
    answers.
    \item \jargon{Simplification}
    \begin{enumerate}
        \item Find negative literals without answers (conditional
        nor unconditional) and conclude the negation is true.
	\item Propagate this by simplifying answers on this
        condition or the negation thereof.  This can make answers
        unconditionally true or false.  Propagate these conclusions.
    \end{enumerate}
    \item \jargon{Answer completion}
    If there are still conditional answers, eliminate answers that
    result from \jargon{positive loops}, e.g., \exam{p :- q.  q :- p.}
    The elimination is done using a tabled Prolog program that reasons
    over the conditional answers.\footnote{See \file{boot/tabling.pl},
    answer_completion/1}. Removed answers may lead to further
    simplification, which in turn may make further answer completion
    possible.  The last two steps must be executed until fixed point
    is reached.
\end{enumerate}

Answers that remain conditional after the above process are considered
to belong to the third truth value (indeterminate).

\subsection{Implementation details for WFS}
\label{sec:implwfs}

First of all, we need to keep track of the conditions introduced by
assuming a negative literal is true or using a conditional answer from a
table. Similar to the XSB \jargon{delay register} we use something that
is is effectively the same as a backtrackable global variable (see
b_setval/2 and b_getval/2), but manipulated at a lower level.  This
list is updated by

\begin{itemize}
    \item Using a conditional answer from a completed trie.  These are always
    \jargon{positive delay elements}.
    \item Getting work from a worklist.  Normally this is an answer/dependency
    pair and the answer is handled the same as above. Assuming a
    negative literal to be true however is also handled by this code,
    in which case a \jargon{negative delay element} is pushed.
\end{itemize}

There are three different delay elements that are represented by the
following Prolog terms:

\begin{itemize}
    \item \arg{ATrie} (an answer trie) represents a negative delay element
    for the variant goal represented by this answer trie.
    \item \arg{ATrie}+\arg{ANode} (a term \functor{+}{2} holding an
    answer trie and an answer node in this trie) represents a ground
    positive delay element.
    \item \arg{ATrie}+\arg{Answer} (as above, but using an answer term)
    is used for non-ground positive delay elements. This is required for
    e.g., \exam{q(X) :- p(X), X = 1}, where p/1 is a tabled goal
    and \term{p}{Var} has a conditional answer. This must add
    \term{q}{1} with condition \term{p}{1} rather than condition
    \term{p}{Var}.
\end{itemize}

Finally, if the execution is suspended we must restore the same delay
list for running the continuation. This requires us to extend the
\functor{dependency}{4} term in \figref{leader10} to
\functor{dependency}{5}, where the last argument holds the delay list at
the moment the dependency is created.

If an answer is added and the delay list is not empty it is added as a
conditional answer or, if the answer is already in the answer trie, its
condition is updated. In general the condition is a disjunction of
conjunctions. If an unconditional answer is already present the
conditional answer is ignored. If a conditional answer is present and
the new answer is unconditional, the condition is removed. Finally, if
the condition is different from any already registered condition the
disjunction is extended with a new conjunction.

Each delay element is represented by a C structure consisting of the
items below. A conjunction is represented as an array of such structures
and the disjunction as an array of conjunctions.

\begin{itemize}
    \item A pointer to an answer trie.
    \item Either \const{NULL} (negative delay element), a pointer to
    an answer node (positive delay element with ground answer)
    or a record (see \secref{record}) (positive delay element with a
    non-ground answer).
\end{itemize}

If a condition is added, we add the conditional answer (a trie node) to
the dynamic array of depending answers associated with each worklist
referenced in the condition. For example if \exam{p :- tnot(q), r} adds
a condition \exam{tnot(q),r} to the answer of p/0 this answer is
associated with the worklists for q/0 and r/0. This representation,
which is similar to the one used by XSB \cite{SAGONAS20001} allows for
executing the simplification process described above with limited
search. The only search required is finding the right delay element
inside the delay condition associated with an answer.


\section{Recorded terms}
\label{sec:record}

At various places the tabling implementation stores Prolog terms on the
program heap (malloc() area). Traditionally SWI-Prolog uses a
\jargon{record} for that. Records are used by findall/3, the classic
recorded database (recorda/3) and C copy that wishes to maintain a copy
of an arbitrary Prolog term. A record serializes a term as a sequence of
instructions and contains size information that allows pre-allocating
the required space before building the term.

The tabling implementation primarily uses Prolog terms on the program
heap for dependencies (the \functor{dependency}{5} term). Restoring
dependencies is a frequent operation, typically much more frequent than
creating a dependency. For this reason we introduced \jargon{fast_heap}
terms. A fast_heap term represents a term exactly as it appears on the
global stack, together with \jargon{relocation data}. Fast heap terms
are created using duplicate_term/2 (a copy_term/2 variant that copies
ground subterms), copying the result to the heap and discarding the
copy. Restoring such a term implies a memcpy() followed by a adding the
same offset to each element in the relocation data.

\bibliographystyle{name}
\bibliography{swipl}

\printindex

\end{document}
